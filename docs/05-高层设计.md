# 草莓栽培智能灌溉系统 - 高层设计与测试计划

## 四、高层设计

### 命名规范

#### 1. 总体原则
- **清晰性 (Clarity)**：名称应能清晰地表明其功能或含义，无需额外注释。
- **一致性 (Consistency)**：在整个项目中保持相同的命名风格和模式。
- **驼峰命名法 (CamelCase)**：
  - 大驼峰/PascalCase：`UserController`, `IrrigationRule`（用于类、接口、枚举、数据库表名）
  - 小驼峰/camelCase：`currentHumidity`, `getDeviceById()`（用于方法、变量、字段、数据库列名）
- **分隔符**：
  - REST API端点：使用连字符 `-` 分隔单词，全小写，例如 `/api/irrigation-rules`。
  - MQTT主题：使用正斜杠 `/` 分隔层级，例如 `sensor/data/farm-1`。
  - 包名：使用点号 `.` 分隔，全小写，例如 `com.strawberry.irrigation.module.auth`。

#### 2. 后端 (Spring Boot) 命名规范

##### 2.1 包结构 (Package Structure)
遵循模块化划分，包名应明确体现模块职责。
```
com.strawberry.irrigation
├── common
│   ├── config        // 配置类
│   ├── exception     // 全局异常处理
│   ├── utils         // 工具类
│   └── response      // 统一响应体
├── module_auth       // 认证授权模块
│   ├── controller
│   ├── service
│   ├── repository
│   ├── model
│   │   ├── dto       // Data Transfer Object
│   │   ├── entity    // JPA Entity
│   │   └── vo        // Value Object (for response)
│   └── config        // 模块特定配置（如Security）
├── module_user       // 用户管理模块
├── module_device     // 设备数据模块
├── module_control    // 灌溉控制模块
└── module_admin      // 系统管理模块
```

##### 2.2 类 (Class) 与接口 (Interface)
- **Controller类**：`[实体名]Controller`，如 `UserController`, `AuthController`, `IrrigationLogController`。
- **Service接口**：`[实体名]Service`，如 `UserService`。
- **Service实现类**：`[实体名]ServiceImpl`，如 `UserServiceImpl`。
- **Repository接口**：`[实体名]Repository`，如 `SensorDataRepository`。
- **实体类 (Entity)**：使用大驼峰，如 `User`, `Device`, `IrrigationRule`。
- **DTO/VO类**：`[实体名][操作][Dto/Vo]`，如 `UserCreateDto`, `LoginVo`, `DeviceStatusVo`。

##### 2.3 方法 (Method)
- **Service/Repository方法**：
  - 获取单个对象：`get[Entity]ById`, `find[Entity]ById`
  - 获取多个对象：`getAll[Entities]`, `findAllBy[Condition]`
  - 新增：`create[Entity]`, `save[Entity]`
  - 更新：`update[Entity]`
  - 删除：`delete[Entity]ById`
  - 业务操作：`checkSoilMoisture`, `triggerIrrigation`, `validateCredentials`
- **Controller方法**：应映射HTTP方法。
  - `get[Entity]` -> GET `/api/entities`
  - `create[Entity]` -> POST `/api/entities`
  - `update[Entity]` -> PUT `/api/entities/{id}`
  - `delete[Entity]` -> DELETE `/api/entities/{id}`

#### 3. REST API 端点命名规范
- **资源导向**：API端点应代表资源，使用名词复数。
- **HTTP方法**：
  - GET：查询/获取资源
  - POST：创建新资源
  - PUT：更新整个资源
  - PATCH：部分更新资源
  - DELETE：删除资源
- **示例**：
  - GET `/api/users`：获取用户列表
  - POST `/api/users`：创建新用户
  - GET `/api/users/{id}`：获取特定用户
  - PUT `/api/users/{id}`：更新特定用户
  - DELETE `/api/users/{id}`：删除特定用户
  - GET `/api/devices/{id}/current-status`：获取设备的当前状态（一个子资源）
  - POST `/api/irrigation/trigger-manual`：触发手动灌溉（特殊操作，可用动词）

#### 4. 数据库命名规范
- **表名 (Table)**：使用蛇形命名法 (snake_case)，小写字母+下划线，使用复数名词。例如 `users`, `devices`, `sensor_data`, `irrigation_rules`。
- **列名 (Column)**：使用蛇形命名法 (snake_case)。例如 `user_id`, `created_at`, `soil_humidity_value`。
- **外键 (Foreign Key)**：`[关联表名]_id`，例如 `device_id`。
- **索引 (Index)**：`idx_[表名]_[列名]`，例如 `idx_sensor_data_timestamp`。

#### 5. MQTT 主题命名规范
主题结构应清晰标识出设备、数据类型和操作意图。
- **格式**：`[系统名]/[设备类型]/[设备ID]/[数据或指令类型]`
- **数据上报 (设备 → 平台)**：`strawberry/sensor/{device-id}/data`
  - payload示例：`{"humidity": 45.2, "temperature": 25.1, "timestamp": 1629999999}`
- **控制指令 (平台 → 设备)**：`strawberry/actuator/{device-id}/control`
  - payload示例：`{"command": "PUMP_ON", "duration": 60}` 或 `{"pump_status": 1}`

#### 6. 前端命名规范
- **组件 (Components)**：使用PascalCase，如 `SensorChart.vue`, `DeviceList.vue`。
- **变量/函数**：使用camelCase，如 `currentUser`, `fetchDeviceData()`。
- **CSS类名**：使用BEM（Block__Element--Modifier）或kebab-case，如 `.device-card`, `.device-card__title--active`。

### 核心服务与操作命名示例

| 模块         | 服务类名 (Service)       | 核心方法示例 (Service Methods)                                                                 | API端点示例                                                                 |
|--------------|--------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 认证授权     | `AuthService`            | `login(LoginDto dto)`, `register(UserCreateDto dto)`, `refreshToken(String token)`             | POST `/api/auth/login` <br> POST `/api/auth/register`                       |
| 用户管理     | `UserService`            | `getUserById(Long id)`, `updateUser(UserUpdateDto dto)`, `disableUser(Long id)`                 | GET `/api/users/{id}` <br> PUT `/api/users/{id}`                            |
| 设备数据     | `SensorDataService`      | `saveSensorData(SensorDataDto dto)`, `getCurrentData(String deviceId)`, `getHistoricalData(...)` | GET `/api/device/{id}/current-data` <br> GET `/api/device/{id}/history`     |
| 灌溉控制     | `IrrigationControlService`| `triggerManualIrrigation(Long deviceId, int duration)`, `evaluateAutoRules()`, `getPumpStatus(...)` | POST `/api/irrigation/manual` <br> GET `/api/irrigation/status/{id}`        |
| 系统管理     | `DeviceManagementService`| `registerDevice(DeviceDto dto)`, `getAllDevices()`                                              | POST `/api/admin/devices` <br> GET `/api/admin/devices`                     |


## 测试用例

基于“草莓栽培智能灌溉系统”的模块化单体架构，制定详细的可执行测试计划与测试用例。

# 草莓栽培智能灌溉系统 - 测试计划

## 1. 测试目标
确保系统功能符合需求规格说明，核心业务流程（数据采集、自动灌溉、手动控制）正确无误，系统具有足够的稳定性和安全性，满足用户基本使用需求。

## 2. 测试策略与范围
本测试计划将采用分阶段测试策略，覆盖从底层代码到最终用户界面的全部流程。
- **单元测试**：针对核心后端服务和工具类。
- **集成测试**：针对API接口、数据库交互、MQTT消息收发。
- **系统测试**：将系统作为一个整体，进行端到端（E2E）业务流程测试。
- **验收测试**：模拟用户真实使用场景，验证功能是否满足需求。

> 注：由于是个人项目，前端（UI）的自动化测试暂不纳入，以手动测试为主。测试重点将放在核心后端逻辑和API上。

## 3. 测试环境
- **测试环境**：本地开发环境或一台独立的阿里云测试服务器。
- **部署方式**：使用 `docker-compose` 启动所有依赖服务（PostgreSQL, TimescaleDB, Redis, EMQX）。
- **后端应用**：启动一个专用于测试的Spring Boot实例，可配置 `application-test.yml` 连接测试数据库。
- **设备模拟器**：编写一个简单的测试用MQTT客户端脚本，用于模拟传感器上报数据和接收控制指令。

## 4. 测试资源
- **工具**：Postman, JUnit 5, Mockito, MQTTX（或任何MQTT客户端工具用于调试）。
- **人员**：开发者本人。

## 5. 详细测试用例

### TC001: 用户注册与登录
- **测试目标**：验证认证授权模块的正常工作。
- **前置条件**：系统运行，数据库已清空。
- **测试步骤**：
  1. (API) 调用 `POST /api/auth/register`，传入用户名、密码等信息。
  2. 验证返回HTTP状态码为 `201 Created`，且返回信息中包含JWT令牌。
  3. (API) 使用注册的账号密码调用 `POST /api/auth/login`。
  4. 验证返回HTTP状态码为 `200 OK`，且返回了有效的JWT令牌。
  5. (API) 使用获取的JWT令牌调用一个需要认证的接口（如 `GET /api/users/me`）。
  6. 验证能够成功获取用户信息。
- **预期结果**：注册、登录、令牌验证流程全部成功。

### TC002: 传感器数据接收与存储
- **测试目标**：验证设备数据模块能正确接收、解析并存储MQTT消息。
- **前置条件**：系统运行，已有一个注册好的设备ID（如 `sensor-001`）。
- **测试步骤**：
  1. (模拟器) 使用MQTT客户端向主题 `strawberry/sensor/sensor-001/data` 发布一条消息：  
     `{"humidity": 35.5, "temperature": 22.1, "timestamp": 1629999999}`。
  2. (等待2秒)
  3. (API) 调用 `GET /api/device/sensor-001/current-data`，使用管理员或所属用户的JWT令牌。
  4. 验证返回的HTTP状态码为 `200`，且返回的JSON中湿度值约为 `35.5`。
  5. (DB) 直接连接TimescaleDB数据库，查询 `sensor_data` 表，应有一条 `device_id` 为 `sensor-001` 且湿度为 `35.5` 的新记录。
- **预期结果**：数据成功通过MQTT进入系统，并同时更新了缓存和数据库。

### TC003: 手动控制灌溉设备
- **测试目标**：验证用户能通过API成功控制设备。
- **前置条件**：系统运行，用户已登录，有一个水泵设备ID（如 `pump-001`）。
- **测试步骤**：
  1. (模拟器) 订阅主题 `strawberry/actuator/pump-001/control` 以接收指令。
  2. (API) 调用 `POST /api/irrigation/manual`，Body:  
     `{ "deviceId": "pump-001", "command": "START", "duration": 60 }`，附上JWT令牌。
  3. 验证API返回 `200 OK` 及成功信息。
  4. (模拟器) 验证在订阅的主题上收到了预期的JSON控制指令（如 `{"command": "START", "duration": 60}`）。
  5. (API) 调用 `GET /api/irrigation/status/pump-001`。
  6. 验证返回状态为“开启”（或 `true`）。
- **预期结果**：API调用成功，且正确的MQTT控制消息被发布，设备状态在系统中被更新。

### TC004: 自动灌溉规则触发
- **测试目标**：验证当传感器数据低于阈值时，系统能自动触发灌溉。
- **前置条件**：系统运行，已为设备 `sensor-001` 和 `pump-001` 创建一条自动规则：“当湿度低于40%时，开启水泵60秒”。
- **测试步骤**：
  1. (模拟器) 订阅主题 `strawberry/actuator/pump-001/control`。
  2. (模拟器) 发布一条低湿度数据：`{"humidity": 35.0, "temperature": 22.1, "timestamp": 1629999999}`。（触发规则）
  3. (模拟器) 验证收到了“START”指令。
  4. (API) 调用 `GET /api/irrigation/logs?deviceId=pump-001`。
  5. 验证返回的日志列表中有一条最新的记录，其触发原因为 `AUTO`（自动），且状态为 `SUCCESS`。
- **预期结果**：系统根据规则自动判断并成功下发灌溉指令，且生成了正确的操作日志。

### TC005: 权限隔离验证
- **测试目标**：验证普通用户无法访问或操作其他用户的数据。
- **前置条件**：系统中有两个用户：UserA 和 UserB，各自拥有不同的设备。
- **测试步骤**：
  1. (API) 使用 UserA 的令牌调用 `GET /api/device/{UserB的设备ID}/current-data`。
  2. 验证返回HTTP状态码为 `403 Forbidden` 或 `404 Not Found`。
  3. (API) 使用 UserA 的令牌尝试为 UserB 的设备发送控制指令。
  4. 验证返回同样的错误状态码。
- **预期结果**：系统成功阻止了越权访问，保证了数据隔离。

## 6. 测试执行计划（阶段与顺序）

### 1. 第一阶段：单元测试 (开发过程中进行)
- **对象**：核心Service类（如 `IrrigationControlService` 的规则判断逻辑）、工具类。
- **工具**：JUnit 5 + Mockito。
- **执行**：在IDE中右键点击类/方法，选择运行测试。
- **示例（伪代码）**：
  ```java
  @Test
  void shouldTriggerIrrigation_WhenHumidityBelowThreshold() {
      // 1. 准备 Mock 数据和依赖
      SensorData lowHumidityData = new SensorData("sensor-1", 35.0, 25.0, Instant.now());
      when(sensorRepository.findLatest(anyString())).thenReturn(Optional.of(lowHumidityData));
  
      // 2. 执行方法
      irrigationService.evaluateAutoRules();
  
      // 3. 验证行为：verify that mqttClient.publish was called with the expected command
      verify(mqttClient).publish(
          eq("strawberry/actuator/pump-1/control"), 
          anyString()
      );
  }
  ```

### 2. 第二阶段：集成测试 (API与数据库)
- **对象**：所有Controller API端点。
- **工具**：Postman (推荐)。
- **执行**：
  1. 在Postman中创建集合 `Strawberry Irrigation System`。
  2. 为每个API编写测试用例，使用环境变量动态管理JWT令牌（在登录测试后的脚本中自动设置）。
  3. 使用Postman的 `Collection Runner` 来自动化运行整个集合，进行回归测试。

### 3. 第三阶段：端到端（E2E）系统测试 (手动)
- **对象**：完整业务流程。
- **执行**：按顺序执行测试用例 TC001 → TC002 → TC004。
- **流程**：注册用户 → 配置设备 → 模拟传感器上报低湿度数据 → 观察自动灌溉是否触发 → 验证数据库和日志记录。
- **此阶段需要启动所有组件**（App, DB, Redis, MQTT, 模拟器）。

### 4. 第四阶段：验收测试 (手动)
- **执行**：模拟真实用户操作。
  1. 在浏览器中打开前端页面。
  2. 登录系统。
  3. 查看数据图表是否正常渲染。
